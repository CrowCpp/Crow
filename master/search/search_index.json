{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"getting_started/a_simple_webpage/","title":"A Simple Webpage","text":"<p>Hello World is a good start, but what if you want something a bit more fancy.. Something like an HTML document saying \"Hello World\". If that's what you want, follow along:</p>"},{"location":"getting_started/a_simple_webpage/#basic-webpage","title":"Basic Webpage","text":"<p>Let's start our webpage with.. well.. a webpage. But before we create a webpage we need to place it somewhere Crow recognizes, for now this directory is going to be called <code>templates</code>, but we can change it later.</p> <p>Once our <code>templates</code> folder is created, we can create our HTML document inside it, let's call it <code>fancypage.html</code>.</p> <p>After that we can just place something simple inside it like: templates/fancypage.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n  &lt;p&gt;Hello World!&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>  Now that we have our HTML page ready, let's take our Hello World example from earlier: <pre><code>#include \"crow.h\"\n//#include \"crow_all.h\"\n\nint main()\n{\n    crow::SimpleApp app; //define your crow application\n\n    //define your endpoint at the root directory\n    CROW_ROUTE(app, \"/\")([](){\n        return \"Hello world\";\n    });\n\n    //set the port, set the app to run on multiple threads, and run the app\n    app.port(18080).multithreaded().run();\n}\n</code></pre> </p> <p>And now let's modify it so that it returns our cool page: /main.cpp<pre><code>#include \"crow.h\"\n//#include \"crow_all.h\"\n\nint main()\n{\n    crow::SimpleApp app;\n\n    //define your endpoint at the root directory\n    CROW_ROUTE(app, \"/\")([](){\n        auto page = crow::mustache::load_text(\"fancypage.html\");\n        return page;\n    });\n\n    app.port(18080).multithreaded().run();\n}\n</code></pre></p> <p>Your project should look something something like: <pre><code>./\n |-templates/\n |          |-fancypage.html\n |\n |-main.cpp\n |-crow_all.h\n</code></pre> or <pre><code>./\n |-templates/\n |          |-fancypage.html\n |\n |-crow/\n |     |-include/...\n |     |-crow.h\n |-main.cpp\n</code></pre></p> <p>Once the code is done compiling, if we call <code>http://localhost:18080/</code> we get our Hello World in an HTML document rather than just plain text.</p> <p>Note</p> <p>Compilation instructions are available for Linux, MacOS, and Windows</p>"},{"location":"getting_started/a_simple_webpage/#template-webpage-with-a-variable","title":"Template Webpage with a variable","text":"<p>But we can make things even more exciting, we can greet a user by their name instead!!</p> <p>Let's start with our webpage, and modify it with a little bit of mustache syntax: templates/fancypage.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n  &lt;p&gt;Hello {{person}}!&lt;/p&gt; &lt;!--(1)--&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <ol> <li><code>{{}}</code> in mustache define a simple variable</li> </ol> <p> Now let's modify our C++ code to use the variable we just added to our webpage (or template): /main.cpp<pre><code>#include \"crow.h\"\n//#include \"crow_all.h\"\n\nint main()\n{\n    crow::SimpleApp app;\n\n    //define your endpoint at the root directory\n    CROW_ROUTE(app, \"/&lt;string&gt;\")([](std::string name){ // (1)\n        auto page = crow::mustache::load(\"fancypage.html\"); // (2)\n        crow::mustache::context ctx ({{\"person\", name}}); // (3)\n        return page.render(ctx); //(4)\n    });\n\n    app.port(18080).multithreaded().run();\n}\n</code></pre></p> <ol> <li>We are adding a <code>string</code> variable to the URL and a counterpart (<code>std::string name</code>) to our route - this can be anything the user wants.</li> <li>We are using <code>load()</code> instead of <code>load_text()</code> since we have an actual variable now.</li> <li>We are creating a new context containing the <code>person</code> variable from our template and the <code>name</code> we got from the URL.</li> <li>We are using <code>render(ctx)</code> to apply our context to the template.</li> </ol> <p>Now (after compiling the code and running the executable a second time) calling <code>http://localhost:18080/Bob</code> should return a webpage containing \"Hello Bob!\". We did it!</p> <p>For more details on templates and HTML pages in Crow please go here</p>"},{"location":"getting_started/your_first_application/","title":"Your First Application","text":"<p>This page shows how you can get started with a simple hello world application.</p>"},{"location":"getting_started/your_first_application/#1-include","title":"1. Include","text":"<p>Starting with an empty <code>main.cpp</code> file, first add <code>#include \"crow.h\"</code> or <code>#include \"crow_all.h\"</code> if you're using the single header file.</p> <p>Note</p> <p>If you are using version v0.3, then you have to put <code>#define CROW_MAIN</code> at the top of one and only one source file.</p>"},{"location":"getting_started/your_first_application/#2-app-declaration","title":"2. App declaration","text":"<p>Next Create a <code>main()</code> and declare a <code>crow::SimpleApp</code> inside, your code should look like this <pre><code>int main()\n{\n    crow::SimpleApp app;\n}\n</code></pre> The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here.</p>"},{"location":"getting_started/your_first_application/#3-adding-routes","title":"3. Adding routes","text":"<p>Once you have your app, the next step is to add routes (or endpoints). You can do so with the <code>CROW_ROUTE</code> macro. <pre><code>CROW_ROUTE(app, \"/\")([](){\n    return \"Hello world\";\n});\n</code></pre> For more details on routes, please go here.</p>"},{"location":"getting_started/your_first_application/#4-running-the-app","title":"4. Running the app","text":"<p>Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the <code>run()</code> method. <pre><code>app.port(18080).multithreaded().run();\n</code></pre> Please note that the <code>port()</code> and <code>multithreaded()</code> methods aren't needed, though not using <code>port()</code> will cause the default port (<code>80</code>) to be used.</p>"},{"location":"getting_started/your_first_application/#putting-it-all-together","title":"Putting it all together","text":"<p>Once you've followed all the steps above, your code should look similar to this</p> main.cpp<pre><code>#include \"crow.h\"\n//#include \"crow_all.h\"\n\nint main()\n{\n    crow::SimpleApp app; //define your crow application\n\n    //define your endpoint at the root directory\n    CROW_ROUTE(app, \"/\")([](){\n        return \"Hello world\";\n    });\n\n    //set the port, set the app to run on multiple threads, and run the app\n    app.port(18080).multithreaded().run();\n}\n</code></pre> <p>You then need to compile your code on your Linux, MacOS, or Windows machine</p> <p>After building your <code>.cpp</code> file and running the resulting executable, you should be able to access your endpoint at http://localhost:18080. Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.</p>"},{"location":"getting_started/setup/linux/","title":"Linux","text":"<p>Here's how you can install Crow on your favorite GNU/Linux distro.</p>"},{"location":"getting_started/setup/linux/#getting-crow","title":"Getting Crow","text":""},{"location":"getting_started/setup/linux/#requirements","title":"Requirements","text":"<ul> <li>C++ compiler with at least C++11 support.</li> <li>Asio development headers (1.10.9 or later).</li> <li>(optional) ZLib for HTTP Compression.</li> <li>(optional) OpenSSL for HTTPS support.</li> <li>(optional) CMake for building tests, examples, and/or installing Crow.</li> <li>(optional) Python3 to build tests and/or examples.</li> </ul> <p>Note</p> <p>Crow's CI uses <code>g++-9.4</code> and <code>clang-10.0</code> running on AMD64 (x86_64) and ARM64v8 architectures.</p> <p></p>"},{"location":"getting_started/setup/linux/#using-a-package-manager","title":"Using a package Manager","text":"<p>You can install Crow on GNU/Linux as a pre-made package</p> Debian/Ubuntu <p>Simply download Crow's <code>.deb</code> file from the release section and Install it.</p> Arch <p>Crow is available for Arch based distros through the AUR package <code>crow</code>.</p> <p></p>"},{"location":"getting_started/setup/linux/#release-package","title":"Release package","text":"<p>Crow provides an archive containing the framework and CMake files, just copy the <code>include</code> folder to <code>/usr/local/include</code> and <code>lib</code> folder to <code>/usr/local/lib</code>. You can also download the <code>crow_all.h</code> file and simply include that into your project. </p>"},{"location":"getting_started/setup/linux/#installing-from-source","title":"Installing from source","text":""},{"location":"getting_started/setup/linux/#using-cmake","title":"Using CMake","text":"<ol> <li>Download Crow's source code (Either through Github's UI or by using <code>git clone https://github.com/CrowCpp/Crow.git</code>).</li> <li>Run <code>mkdir build</code> inside of crow's source directory.</li> <li>Navigate to the new \"build\" directory and run the following: <code>cmake .. -DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF</code></li> <li>Run <code>make install</code>.</li> </ol> <p>Note</p> <p>You can ignore <code>-DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF</code> if you want to build the Examples and Unit Tests.</p> <p>Note</p> <p>While building you can set the <code>CROW_FEATURES</code> variable (as a <code>;</code> separated list). You can use an argument such as <code>-DCROW_FEATURES=\"ssl;compression\"</code>.</p> <p>Note</p> <p>You can uninstall Crow at a later time using <code>make uninstall</code>.</p> <p></p>"},{"location":"getting_started/setup/linux/#manually","title":"Manually","text":"<p>Crow can be installed manually on your Linux computer.</p>"},{"location":"getting_started/setup/linux/#multiple-header-files","title":"Multiple header files","text":"Project Only <p>Copy Crow's <code>include</code> directory to your project's <code>include</code> directory.</p> System wide <p>Copy Crow's <code>include</code> directory to the <code>/usr/local/include</code> directory.</p>"},{"location":"getting_started/setup/linux/#single-header-crow_allh","title":"Single header (crow_all.h)","text":"<p>Warning</p> <p><code>crow_all.h</code> is recommended only for small, possibly single source file projects, and ideally should not be installed on your system.</p> <p>navigate to the <code>scripts</code> directory and run <code>./merge_all.py ../include crow_all.h</code>. This will generate a <code>crow_all.h</code> file that you can use in your projects.</p> <p>Note</p> <p>You can also include or exclude middlewares from your <code>crow_all.h</code> by using <code>-i</code> or <code>-e</code> followed by the middleware header file names separated by a comma (e.g. <code>merge_all.py ../include crow_all.h -e cookie_parser</code> to exclude the cookie parser middleware).</p>"},{"location":"getting_started/setup/linux/#compiling-your-project","title":"Compiling your project","text":""},{"location":"getting_started/setup/linux/#using-cmake_1","title":"Using CMake","text":"<p>In order to get your CMake project to work with Crow, all you need are the following lines in your CMakeLists.txt: <pre><code>find_package(Crow)\ntarget_link_libraries(your_project PUBLIC Crow::Crow)\n</code></pre> From there CMake should handle compiling and linking your project.</p> <p>Note</p> <p>For optional features like HTTP Compression or HTTPS you can set the <code>CROW_FEATURES</code> variable using lines such as <code>set(CROW_FEATURES \"ssl;compression\")</code>, <code>set(CROW_FEATURES ssl compression)</code>, or <code>set(CROW_FEATURES ssl)</code>.</p>"},{"location":"getting_started/setup/linux/#directly-using-a-compiler","title":"Directly using a compiler","text":"<p>All you need to do is run the following command: <pre><code>g++ main.cpp -lpthread\n</code></pre> You can use arguments like <code>-DCROW_ENABLE_DEBUG</code>, <code>-DCROW_ENABLE_COMPRESSION -lz</code> for HTTP Compression, or <code>-DCROW_ENABLE_SSL -lssl</code> for HTTPS support, or even replace g++ with clang++.</p>"},{"location":"getting_started/setup/macos/","title":"MacOS","text":"<p>Here's how you can install Crow on your Mac.</p>"},{"location":"getting_started/setup/macos/#getting-crow","title":"Getting Crow","text":""},{"location":"getting_started/setup/macos/#from-a-release","title":"From a release","text":""},{"location":"getting_started/setup/macos/#archive","title":"Archive","text":"<p>Crow provides an archive containing the framework and CMake files, You will only need the <code>include</code> folder inside that archive.</p>"},{"location":"getting_started/setup/macos/#single-header-file","title":"Single header file","text":"<p>You can also download the <code>crow_all.h</code> file which replaces the <code>include</code> folder.</p>"},{"location":"getting_started/setup/macos/#from-source","title":"From Source","text":"<p>To get Crow from source, you only need to download the repository (as a <code>.zip</code> or through <code>git clone https://github.com/CrowCpp/Crow.git</code>).</p>"},{"location":"getting_started/setup/macos/#include-folder","title":"include folder","text":"<p>Once you've downloaded Crow's source code, you only need to take the <code>include</code> folder.</p>"},{"location":"getting_started/setup/macos/#single-header-file_1","title":"Single header file","text":"<p>You can generate your own single header file by navigating to the <code>scripts</code> folder with your terminal and running the following command: <pre><code>python3 merge_all.py ../include crow_all.h\n</code></pre> This will generate a <code>crow_all.h</code> file which you can use in the following steps</p> <p>Warning</p> <p><code>crow_all.h</code> is recommended only for small, possibly single source file projects. For larger projects, it is advised to use the multi-header version.</p>"},{"location":"getting_started/setup/macos/#setting-up-your-crow-project","title":"Setting up your Crow project","text":""},{"location":"getting_started/setup/macos/#using-xcode","title":"Using XCode","text":"<ol> <li>Download and install Homebrew.</li> <li>Run <code>brew install asio</code> in your terminal.</li> <li>Create a new XCode project (macOS -&gt; Command Line Tool).</li> <li> <p>Change the following project settings:</p> Multiple Headers <ol> <li>Add header search paths for crow's include folder and asio's folder (<code>/usr/local/include</code>, <code>/usr/local/Cellar/asio/include</code>, and where you placed Crow's <code>include</code> folder)</li> <li>Add linker flags (<code>-lpthread</code>)</li> </ol> Single Header <ol> <li>Place <code>crow_all.h</code> inside your project folder and add it to the project in XCode (you need to use File -&gt; Add files to \"project_name\")</li> <li>Add header search paths for asio's folder:</li> <li><code>/usr/local/include</code>, and</li> <li>Silicon: <code>/opt/homebrew/Cellar/asio/&lt;asio_version&gt;/include</code></li> <li>Intel: <code>/usr/local/Cellar/asio/&lt;asio_version&gt;/include</code></li> <li>Add linker flags (<code>-lpthread</code> for g++, <code>-pthread</code> for clang++)</li> </ol> </li> <li> <p>Write your Crow application in <code>main.cpp</code> (something like the Hello World example will work).</p> </li> <li>Press <code>\u25b6</code> to compile and run your Crow application.</li> </ol>"},{"location":"getting_started/setup/macos/#building-crows-testsexamples","title":"Building Crow's tests/examples","text":"<p>Note</p> <p>This tutorial can be used for Crow projects built with CMake as well</p> <ol> <li>Download and install Homebrew.</li> <li>Run <code>brew install cmake asio</code> in your terminal.</li> <li>Get Crow's source code (the entire source code).</li> <li>Run the following Commands:<ol> <li><code>mkdir build</code></li> <li><code>cd build</code></li> <li><code>cmake ..</code></li> <li><code>make -j12</code></li> </ol> </li> </ol> <p>Note</p> <pre><code>You can add options like `-DCROW_FEATURES=\"ssl;compression\"` or `-DCROW_AMALGAMATE` to `cmake ..` to build optional tests/examples for HTTP Compression or HTTPS.\n</code></pre>"},{"location":"getting_started/setup/macos/#compiling-using-a-compiler-directly","title":"Compiling using a compiler directly","text":"<p>All you need to do is run the following command: <pre><code>g++ main.cpp -lpthread\n</code></pre></p> <p>Note</p> <p>You'll need to install GCC via <code>brew install gcc</code>. the Clang compiler should be part of XCode or XCode command line tools.</p> <p>You can use arguments like <code>-DCROW_ENABLE_DEBUG</code>, <code>-DCROW_ENABLE_COMPRESSION -lz</code> for HTTP Compression, or <code>-DCROW_ENABLE_SSL -lssl</code> for HTTPS support, or even replace g++ with clang++.</p> <p>If GCC throws errors and your program does not compile, you may be using C++03 instead of \u2265C++11. Use the flag <code>-std=c++11</code>.</p>"},{"location":"getting_started/setup/windows/","title":"Windows","text":"<p>Here's how you can install Crow on your Windows machine.</p>"},{"location":"getting_started/setup/windows/#getting-and-compiling-crow","title":"Getting and Compiling Crow","text":""},{"location":"getting_started/setup/windows/#using-a-package-manager","title":"Using A package manager","text":""},{"location":"getting_started/setup/windows/#vcpkg","title":"VCPKG","text":"<p>Crow can be simply installed through VCPKG using the command <code>vcpkg install crow</code></p>"},{"location":"getting_started/setup/windows/#manually-source-or-release","title":"Manually (source or release)","text":""},{"location":"getting_started/setup/windows/#microsoft-visual-studio-and-vcpkg","title":"Microsoft Visual Studio and VCPKG","text":"<p>The following guide will use <code>example_with_all.cpp</code> as the Crow application for demonstration purposes. VCPKG will be used only to install Crow's dependencies.</p> <ol> <li>Generate <code>crow_all.h</code> by navigating to the <code>scripts</code> folder and running <code>python3 merge_all.py ..\\include crow_all.h</code>.</li> <li><code>git clone https://github.com/microsoft/vcpkg.git</code></li> <li><code>.\\vcpkg\\bootstrap-vcpkg.bat</code></li> <li><code>.\\vcpkg\\vcpkg integrate install</code></li> <li>Create empty Visual Studio project.</li> <li>In solution explorer, right click the name of your project then click <code>Open Folder in File Explorer</code>.</li> <li>Copy <code>crow_all.h</code>, <code>example_with_all.cpp</code>, <code>vcpkg.json</code> to opened folder.</li> <li>Add <code>crow_all.h</code> to <code>Header Files</code> and <code>example_with_all.cpp</code> to <code>Source Files</code>.</li> <li>In solution explorer, right click the name of your project then click <code>Properties</code>.</li> <li>Under <code>vcpkg</code>, set <code>Use Vcpkg Manifest</code> to <code>Yes</code> and <code>Additional Options</code> to <code>--feature-flags=\"versions\"</code>.</li> <li>Set <code>Debug/Release</code> and <code>x64/x86</code>. </li> <li>Run.</li> </ol>"},{"location":"guides/app/","title":"App","text":"<p>A Crow app defines an interface to allow the developer access to all the different parts of the framework, without having to manually deal with each one. An app allows access to the HTTP server (for handling connections), router (for handling URLs and requests), Middlewares (for extending Crow), among many others.</p> <p>Crow has 2 different app types:</p>"},{"location":"guides/app/#simpleapp","title":"SimpleApp","text":"<p>Has no middlewares.</p>"},{"location":"guides/app/#appm1-m2","title":"App&lt;m1, m2, ...&gt;","text":"<p>Has middlewares.</p>"},{"location":"guides/app/#using-the-app","title":"Using the app","text":"<p>To use a Crow app, simply define <code>crow::SimpleApp</code> or <code>crow::App&lt;m1, m2 ...&gt;</code> if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. <pre><code>app.bindaddr(\"192.168.1.2\").port(443).ssl_file(\"certfile.crt\",\"keyfile.key\").multithreaded().run();\n</code></pre> Or if you like your code neat <pre><code>app.bindaddr(\"192.168.1.2\")\n.port(443)\n.ssl_file(\"certfile.crt\",\"keyfile.key\")\n.multithreaded()\n.run();\n</code></pre></p> <p>Note</p> <p>The <code>run()</code> method is blocking. To run a Crow app asynchronously <code>run_async()</code> should be used instead.</p> <p>Warning</p> <p>When using <code>run_async()</code>, make sure to use a variable to save the function's output (such as <code>auto _a = app.run_async()</code>). Otherwise the app will run synchronously.</p> <p></p> <p>For more info on middlewares, check out this page. For more info on what functions are available to a Crow app, go here.</p>"},{"location":"guides/auth/","title":"HTTP Authorization","text":"<p>While Crow doesn't directly support HTTP authentication, it does provide all the tools you need to build your own. This tutorial will show you how to setup basic and token authentication using Crow.</p>"},{"location":"guides/auth/#shared-information","title":"Shared information","text":"<p>Every way boils down to the same basic flow: - The handler calls a verification function. - The handler provides a <code>request</code> and \\&lt;optionally&gt; a <code>response</code>. - The function returns a <code>bool</code> or <code>enum</code> status. - Handler either continues or stops executing based on the returned status. - Either the function or handler modify and <code>end()</code> the <code>response</code> in case of failure.</p> <p>For the purposes of this tutorial, we will assume that the verification function is defined as <code>bool verify(crow::request req, crow::response res)</code></p>"},{"location":"guides/auth/#basic-auth","title":"Basic Auth","text":"<p>Basic HTTP authentication requires the client to send the Username and Password as a single string, separated by a colon (':') and then encoded as Base64. This data needs to be placed in the <code>Authorization</code> header of the request. A sample header using the credentials \"Username\" and \"Password\" would look like this: <code>Authorization: Basic VXNlcm5hbWU6UGFzc3dvcmQ=</code>.</p> <p>We don't need to worry about creating the request, we only need to extract the credentials from the <code>Authorization</code> header and verify them.</p> <p>Note</p> <p>There are multiple ways to verify the credentials. Most involve checking the username in a database, then checking a hash of the password against the stored password hash for that username. This tutorial will not go over them </p> <p></p> <p>To do this we first need to get the <code>Authorization</code> header as a string by using the following code: <pre><code>std::string myauth = req.get_header_value(\"Authorization\");\n</code></pre> </p> <p>Next we need to isolate our encoded credentials and decode them as follows: <pre><code>std::string mycreds = myauth.substr(6);\nstd::string d_mycreds = crow::utility::base64decode(mycreds, mycreds.size());\n</code></pre> </p> <p>Now that we have our <code>username:password</code> string, we only need to separate it into 2 different strings and verify their validity: <pre><code>size_t found = d_mycreds.find(':');\nstd::string username = d_mycreds.substr(0, found);\nstd::string password = d_mycreds.substr(found+1);\n\n/*Verify validity of username and password here*/\nreturn true; //or false if the username/password are invalid\n</code></pre></p>"},{"location":"guides/auth/#token-auth","title":"Token Auth","text":"<p>Tokens are some form of unique data that a server can provide to a client in order to verify the client's identity later. While on the surface level they don't provide more security than a strong password, they are designed to be less valuable by being temporary and providing limited access. Variables like expiration time and access scopes are heavily reliant on the implementation however.</p>"},{"location":"guides/auth/#access-tokens","title":"Access Tokens","text":"<p>The kind of the token itself can vary depending on the implementation and project requirements: Many services use randomly generated strings as tokens. Then compare them against a database to retrieve the associated user data. Some services however prefer using data bearing tokens. One example of the latter kind is JWT, which uses JSON strings encoded in Base64 and signed using a private key or an agreed upon secret. While this has the added hassle of signing the token to ensure that it's not been tampered with. It does allow for the client to issue tokens without ever needing to present a password or contact a server. The server would simply be able to verify the signature using the client's public key or secret.</p>"},{"location":"guides/auth/#using-an-access-token","title":"Using an Access Token","text":"<p>Authenticating with an access token usually involves 2 stages: The first being acquiring the access token from an authority (either by providing credentials such as a username and a password to a server or generating a signed token). The scope of the token (what kind of information it can read or change) is usually defined in this step.</p> <p>The second stage is simply presenting the Token to the server when requesting a resource. This is even simpler than using basic authentication. All the client needs to do is provide the <code>Authorization</code> header with a keyword (usually <code>Bearer</code>) followed by the token itself (for example: <code>Authorization: Bearer ABC123</code>). Once the client has done that the server will need to acquire this token, which can easily be done as follows:</p> <p><pre><code>std::string myauth = req.get_header_value(\"Authorization\");\nstd::string mycreds = myauth.substr(7); // The length can change based on the keyword used\n\n/*Verify validity of the token here*/\nreturn true; //or false if the token is invalid\n</code></pre>  The way of verifying the token is largely up to the implementation, and involves either Bearer token decoding and verification, or database access, neither of which is in this tutorial's scope.</p>"},{"location":"guides/auth/#refresh-tokens","title":"Refresh Tokens","text":"<p>Some services may choose to provide a refresh token alongside the access token. This token can be used to request a new access token if the existing one has expired. It provides convenience and security in that it makes it possible to acquire new access tokens without the need to expose a password. The downside however is that it can allow a malicious entity to keep its access to a compromised account. As such refresh tokens need to be handled with care, kept secure, and always invalidated as soon as a client logs out or requests a new access token.</p>"},{"location":"guides/auth/#sessions","title":"Sessions","text":"<p>While Crow does not provide built in support for user sessions, a community member was kind enough to provide their own implementation on one of the related issue, their comment along with the code is available here (Please keep in mind that while we appreciate all efforts to push Crow forward, we cannot provide support for this implementation unless it becomes part of the core project).</p>"},{"location":"guides/base64/","title":"Base64","text":""},{"location":"guides/base64/#encoding","title":"Encoding","text":"<p>Using <code>crow::utility::base64encode(mystring, mystring.size())</code> will return a Base64 encoded string. For URL safe Base64 <code>crow::utility::base64encode_urlsafe(mystring, mystring.size())</code> can be used. The key used in the encoding process can be changed, it is a string containing all 64 characters to be used.</p>"},{"location":"guides/base64/#decoding","title":"Decoding","text":"<p> v1.0</p> <p>Using <code>crow::utility::base64decode(mystring, mystring.size())</code> with <code>mystring</code> being a Base64 encoded string will return a plain-text string. The function works with both normal and URL safe Base64. However it cannot decode a Base64 string encoded with a custom key.</p>"},{"location":"guides/blueprints/","title":"Blueprints","text":"<p> v1.0</p> <p>Crow supports Flask-style blueprints. A blueprint is a limited app. It cannot handle networking, but it can handle routes. Blueprints allow developers to compartmentalize their Crow applications, making them much more modular.</p> <p>In order for a blueprint to work, it has to be registered with a Crow app before the app is run. This can be done using <code>app.register_blueprint(blueprint);</code>.</p> <p>Blueprints let you do the following:</p>"},{"location":"guides/blueprints/#define-routes","title":"Define Routes","text":"<p>You can define routes in a blueprint, similarly to how <code>CROW_ROUTE(app, \"/xyz\")</code> works, you can use <code>CROW_BP_ROUTE(blueprint, \"/xyz\")</code> to define a blueprint route.</p>"},{"location":"guides/blueprints/#define-a-prefix","title":"Define a Prefix","text":"<p>Blueprints can have a prefix assigned to them. This can be done when creating a new blueprint as in <code>crow::blueprint bp(\"prefix\");</code>. This prefix will be applied to all routes belonging to the blueprint, turning a route such as <code>/crow/rocks</code> into <code>/prefix/crow/rocks</code>.</p> <p>Warning</p> <p>Unlike routes, blueprint prefixes should contain no slashes.</p>"},{"location":"guides/blueprints/#use-a-custom-static-directory","title":"Use a custom Static directory","text":"<p>Blueprints let you define a custom static directory (relative to your working directory). This can be done by initializing a blueprint as <code>crow::blueprint bp(\"prefix\", \"custom_static\");</code>. This does not have an effect on <code>set_static_file_info()</code>, it's only for when you want direct access to a file.</p> <p>Note</p> <p>Currently changing which endpoint the blueprint uses isn't possible, so whatever you've set in <code>CROW_STATIC_ENDPOINT</code> (default is \"static\") will be used. Making your final route <code>/prefix/static/filename</code>.</p>"},{"location":"guides/blueprints/#use-a-custom-templates-directory","title":"Use a custom Templates directory","text":"<p>Similar to static directories, You can set a custom templates directory (relative to your working directory). To do this you initialize the blueprint as <code>crow::blueprint bp(\"prefix\", \"custom_static\", \"custom_templates\");</code>. Any routes defined for the blueprint will use that directory when calling <code>crow::mustache::load(\"filename.html\")</code>.</p> <p>Note</p> <p>If you want to define a custom templates directory without defining a custom static directory, you can pass the static directory as an empty string. Making your constructor <code>crow::blueprint bp(\"prefix\", \"\", \"custom_templates\");</code>.</p>"},{"location":"guides/blueprints/#define-a-custom-catchall-route","title":"Define a custom Catchall route","text":"<p>You can define a custom catchall route for a blueprint by calling <code>CROW_BP_CATCHALL_ROUTE(blueprint)</code>. This causes any requests with a URL starting with <code>/prefix</code> and no route found to call the blueprint's catchall route. If no catchall route is defined, Crow will default to either the parent blueprint or the app's catchall route.</p>"},{"location":"guides/blueprints/#register-other-blueprints","title":"Register other Blueprints","text":"<p>Blueprints can also register other blueprints. This is done through <code>blueprint.register_blueprint(blueprint_2);</code>. The child blueprint's routes become <code>/prefix/prefix_2/abc/xyz</code>.</p>"},{"location":"guides/compression/","title":"Compression","text":"<p> v0.3</p> <p>Crow supports Zlib compression using Gzip or Deflate algorithms.</p>"},{"location":"guides/compression/#http-compression","title":"HTTP Compression","text":"<p>HTTP compression is by default disabled in crow. Do the following to enable it:  - Define <code>CROW_ENABLE_COMPRESSION</code> in your compiler definitions (<code>g++ main.cpp -DCROW_ENABLE_COMPRESSION</code> for example) or <code>set(CROW_FEATURES compression)</code> in <code>CMakeLists.txt</code>. - Call <code>use_compression(crow::compression::algorithm)</code> on your Crow app. - When compiling your application, make sure that ZLIB is included as a dependency. Either through <code>-lz</code> compiler argument or <code>find_package(ZLIB)</code> in CMake.</p> <p>Note</p> <p>3<sup>rd</sup> point is not needed for MSVC or CMake projects using <code>Crow::Crow</code> since <code>vcpkg.json</code> and Crow's target already include zlib as a dependency.</p> <p>For the compression algorithm you can use <code>crow::compression::algorithm::DEFLATE</code> or <code>crow::compression::algorithm::GZIP</code>. And now your HTTP responses will be compressed.</p>"},{"location":"guides/compression/#websocket-compression","title":"Websocket Compression","text":"<p>Crow currently does not support Websocket compression. Feel free to discuss the subject with us on GitHub if you're feeling adventurous and want to try to implement it. We appreciate all the help.</p>"},{"location":"guides/included-middleware/","title":"Included Middlewares","text":"<p>Crow contains some middlewares that are ready to be used in your application.  Make sure you understand how to enable and use middleware.</p>"},{"location":"guides/included-middleware/#sessions","title":"Sessions","text":"<p>Include: <code>crow/middlewares/session.h</code>  Examples: <code>examples/middlewares/session.cpp</code></p> <p>This middleware can be used for managing sessions - small packets of data associated with a single client that persist across multiple requests. Sessions shouldn't store anything permanent, but only context that is required to easily work with the current client (is the user authenticated, what page did he visit last, etc.).</p>"},{"location":"guides/included-middleware/#setup","title":"Setup","text":"<p>Session data can be stored in multiple ways:</p> <ul> <li><code>crow::InMemoryStore</code> - stores all data in memory</li> <li><code>crow::FileStore</code> - stores all all data in json files</li> <li>A custom store</li> </ul> <p>Always list the CookieParser before the Session <pre><code>using Session = crow::SessionMiddleware&lt;crow::FileStore&gt;;\ncrow::App&lt;crow::CookieParser, Session&gt; app{Session{\n  crow::FileStore{\"/tmp/sessiondata\"}\n}};\n</code></pre></p> <p>Session ids are represented as random alphanumeric strings and are stored in cookies. See the examples for more customization options.</p>"},{"location":"guides/included-middleware/#usage","title":"Usage","text":"<p>A session is basically a key-value map with support for multiple types: strings, integers, booleans and doubles. The map is created and persisted automatically as soon it is first written to.</p> <pre><code>auto&amp; session = app.get_context&lt;Session&gt;(request);\n\nsession.get(\"key\", \"not-found\"); // get string by key and return \"not-found\" if not found\nsession.get(\"int\", -1);\nsession.get&lt;bool&gt;(\"flag\"); // returns default value(false) if not found\n\nsession.set(\"key\", \"new value\");\nsession.string(\"any-type\"); // return any type as string representation\nsession.remove(\"key\");\nsession.keys(); // return list of keys\n</code></pre> <p>Session objects are shared between concurrent requests, this means we can perform atomic operations and even lock the object. <pre><code>session.apply(\"views\", [](int v){return v + 1;}); // this operation is always atomic, no way to get a data race\nsession.mutex().lock(); // manually lock session\n</code></pre></p>"},{"location":"guides/included-middleware/#expiration","title":"Expiration","text":"<p>Expiration can happen either by the cookie expiring or the store deleting \"old\" data.</p> <ul> <li>By default, cookies expire after 30 days. This can be changed with the cookie option in the Session constructor. </li> <li><code>crow::FileStore</code> automatically supports deleting files that are expired (older than 30 days). The expiration age can also be changed in the constructor.</li> </ul> <p>The session expiration can be postponed. This will make the Session issue a new cookie and make the store acknowledge the new expiration time. <pre><code>session.refresh_expiration()\n</code></pre></p>"},{"location":"guides/included-middleware/#cookies","title":"Cookies","text":"<p>Include: <code>crow/middlewares/cookie_parser.h</code>  Examples: <code>examples/middlewares/example_cookies.cpp</code></p> <p>This middleware allows to read and write cookies by using <code>CookieParser</code>. Once enabled, it parses all incoming cookies.</p> <p>Cookies can be read and written with the middleware context. All cookie attributes can be changed as well.</p> <pre><code>auto&amp; ctx = app.get_context&lt;crow::CookieParser&gt;(request);\nstd::string value = ctx.get_cookie(\"key\");\nctx.set_cookie(\"key\", \"value\")\n    .path(\"/\")\n    .max_age(120);\n</code></pre> <p>Note</p> <p>Make sure <code>CookieParser</code> is listed before any other middleware that relies on it.</p>"},{"location":"guides/included-middleware/#cors","title":"CORS","text":"<p>Include: <code>crow/middlewares/cors.h</code>  Examples: <code>examples/middlewares/example_cors.cpp</code></p> <p>This middleware allows to set CORS policies by using <code>CORSHandler</code>. Once enabled, it will apply the default CORS rules globally.</p> <p>The CORS rules can be modified by first getting the middleware via <code>auto&amp; cors = app.get_middleware&lt;crow::CORSHandler&gt;();</code>. The rules can be set per URL prefix using <code>prefix()</code>, per blueprint using <code>blueprint()</code>, or globally via <code>global()</code>. These will return a <code>CORSRules</code> object which contains the actual rules for the prefix, blueprint, or application. For more details go here.</p> <p><code>CORSRules</code> can  be modified using the methods <code>origin()</code>, <code>methods()</code>, <code>headers()</code>, <code>max_age()</code>, <code>allow_credentials()</code>, or <code>ignore()</code>. For more details on these methods and what default values they take go here.</p> <pre><code>auto&amp; cors = app.get_middleware&lt;crow::CORSHandler&gt;();\ncors\n  .global()\n    .headers(\"X-Custom-Header\", \"Upgrade-Insecure-Requests\")\n    .methods(\"POST\"_method, \"GET\"_method)\n  .prefix(\"/cors\")\n    .origin(\"example.com\");\n</code></pre>"},{"location":"guides/json/","title":"JSON","text":"<p>Crow has built in support for JSON data.</p>"},{"location":"guides/json/#type","title":"type","text":"<p>The types of values that <code>rvalue and wvalue</code> can take are as follows:</p> <ul> <li><code>False</code>: from type <code>bool</code>.</li> <li><code>True</code>: from type <code>bool</code>.</li> <li><code>Number</code><ul> <li><code>Floating_point</code>: from type <code>double</code>.</li> <li><code>Signed_integer</code>: from type <code>int</code>.</li> <li><code>Unsigned_integer</code>: from type <code>unsigned int</code>.</li> </ul> </li> <li><code>String</code>: from type <code>std::string</code>.</li> <li><code>List</code>: from type <code>std::vector</code>.</li> <li><code>Object</code>: from type <code>crow::json::wvalue or crow::json::rvalue</code>. This last type means that <code>rvalue or wvalue</code> can have keys.</li> </ul>"},{"location":"guides/json/#rvalue","title":"rvalue","text":"<p>JSON read value, used for taking a JSON string and parsing it into <code>crow::json</code>.</p> <p>You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a <code>wvalue</code>, which can be done by simply writing <code>crow::json::wvalue wval (rval);</code> (assuming <code>rval</code> is your <code>rvalue</code>).</p> <p>For more info on read values go here.</p>"},{"location":"guides/json/#wvalue","title":"wvalue","text":"<p>JSON write value, used for creating, editing and converting JSON to a string.</p> <p>Note</p> <p>setting a <code>wvalue</code> to object type can be done by simply assigning a value to whatever string key you like, something like <code>wval[\"key1\"] = val1;</code>. Keep in mind that val1 can be any of the above types.</p> <p>A <code>wvalue</code> can be treated as an object or even a list (setting a value by using <code>json[3] = 32</code> for example). Please note that this will remove the data in the value if it isn't of List type.</p> <p>Warning</p> <p>JSON does not allow floating point values like <code>NaN</code> or <code>INF</code>, Crow will output <code>null</code> instead of <code>NaN</code> or <code>INF</code> when converting <code>wvalue</code> to a string. (<code>{\"Key\": NaN}</code> becomes <code>{\"Key\": null}</code>)</p> <p></p> <p>Additionally, a <code>wvalue</code> can be initialized as an object using an initializer list, an example object would be <code>wvalue x = {{\"a\", 1}, {\"b\", 2}}</code>. Or as a list using <code>wvalue x = json::wvalue::list({1, 2, 3})</code>, lists can include any type that <code>wvalue</code> supports.</p> <p>An object type <code>wvalue</code> uses <code>std::unordered_map</code> by default, if you want to have your returned <code>wvalue</code> key value pairs be sorted (using <code>std::map</code>) you can add <code>#define CROW_JSON_USE_MAP</code> to the top of your program.</p> <p>A JSON <code>wvalue</code> can be returned directly inside a route handler, this will cause the <code>content-type</code> header to automatically be set to <code>Application/json</code> and the JSON value will be converted to string and placed in the response body. For more information go to Routes.</p> <p>For more info on write values go here.</p> <p>Note</p> <p>Crow's json exceptions can be disabled by using the <code>#define CROW_JSON_NO_ERROR_CHECK</code> macro. This should increase the program speed with the drawback of having unexpected behavious when used incorrectly (e.g. by attempting to parse an invalid json object).</p>"},{"location":"guides/logging/","title":"Logging","text":"<p>Crow comes with a simple and easy to use logging system.</p> <p>Note</p> <p>Currently Crow's Logger is not linked to the Crow application, meaning if an executable has more than one Crow application they'll be sharing any variables or classes relating to Logging.</p>"},{"location":"guides/logging/#setting-up-logging-level","title":"Setting up logging level","text":"<p>You can set up the level at which crow displays logs by using the app's <code>loglevel(crow::LogLevel)</code> method.</p> <p>The available log levels are as follows (please note that setting a level will also display all logs below this level):</p> <ul> <li>Debug</li> <li>Info</li> <li>Warning</li> <li>Error</li> <li>Critical </li> </ul> <p>To set a logLevel, just use <code>app.loglevel(crow::LogLevel::Warning)</code>, This will not show any debug or info logs. It will however still show error and critical logs.</p> <p>Note</p> <p>Setting the Macro <code>CROW_ENABLE_DEBUG</code> during compilation will also set the log level to <code>Debug</code> (unless otherwise set using <code>loglevel()</code>).</p>"},{"location":"guides/logging/#writing-a-log","title":"Writing a log","text":"<p>Writing a log is as simple as <code>CROW_LOG_&lt;LOG LEVEL&gt; &lt;&lt; \"Hello\";</code> (replace&lt;LOG LEVEL&gt; with the actual level in all caps, so you have <code>CROW_LOG_WARNING</code>).</p> <p>Note</p> <p>Log times are reported in GMT timezone by default. This is because HTTP requires all reported times for requests and responses to be in GMT. This can be changed by using the macro <code>CROW_USE_LOCALTIMEZONE</code> which will set only the log timezone to the server's local timezone.</p>"},{"location":"guides/logging/#creating-a-custom-logger","title":"Creating A custom logger","text":"<p> v1.0</p> <p>Assuming you have an existing logger or Crow's default format just doesn't work for you. Crow allows you to use a custom logger for any log made using the <code>CROW_LOG_&lt;LOG LEVEL&gt;</code> macro. All you need is a class extending <code>crow::ILogHandler</code> containing the method <code>void log(std::string, crow::LogLevel)</code>. Once you have your custom logger, you need to set it via <code>crow::logger::setHandler(&amp;MyLogger);</code>. Here's a full example: <pre><code>class CustomLogger : public crow::ILogHandler {\n public:\n  CustomLogger() {}\n  void log(std::string message, crow::LogLevel /*level*/) {\n    // \"message\" doesn't contain the timestamp and loglevel\n    // prefix the default logger does and it doesn't end\n    // in a newline.\n    std::cerr &lt;&lt; message &lt;&lt; std::endl;\n  }\n};\n\nint main(int argc, char** argv) {\n  CustomLogger logger;\n  crow::logger::setHandler(&amp;logger);\n\n  crow::SimpleApp app;\n  CROW_ROUTE(app, \"/\")([]() { return \"Hello\"; });\n  app.run();\n}\n</code></pre></p>"},{"location":"guides/middleware/","title":"Middleware","text":"<p>Middleware is used for altering and inspecting requests before and after calling the handler. In Crow it's very similar to middleware in other web frameworks.</p> <p>All middleware is registered in the Crow application</p> <pre><code>crow::App&lt;FirstMW, SecondMW, ThirdMW&gt; app;\n</code></pre> <p>and is called in this specified order.</p> <p>Any middleware requires the following 3 members:</p> <ul> <li>A context struct for storing request local data.</li> <li>A <code>before_handle</code> method, which is called before the handler.</li> <li>A <code>after_handle</code> method, which is called after the handler.</li> </ul> <p>Warning</p> <p>As soon as <code>response.end()</code> is called, no other handlers and middleware is run, except for after_handlers of already visited middleware.</p>"},{"location":"guides/middleware/#example","title":"Example","text":"<p>A middleware that can be used to guard admin handlers</p> <pre><code>struct AdminAreaGuard\n{\n    struct context\n    {};\n\n    void before_handle(crow::request&amp; req, crow::response&amp; res, context&amp; ctx)\n    {\n        if (req.remote_ip_address != ADMIN_IP)\n        {\n            res.code = 403;\n            res.end();\n        }\n    }\n\n    void after_handle(crow::request&amp; req, crow::response&amp; res, context&amp; ctx)\n    {}\n};\n</code></pre>"},{"location":"guides/middleware/#before_handle-and-after_handle","title":"before_handle and after_handle","text":"<p>There are two possible signatures for before_handle and after_handle</p> <ol> <li> <p>if you only need to access this middleware's context.</p> <pre><code>void before_handle(request&amp; req, response&amp; res, context&amp; ctx)\n</code></pre> </li> <li> <p>To get access to other middlewares context</p> <pre><code>template &lt;typename AllContext&gt;\nvoid before_handle(request&amp; req, response&amp; res, context&amp; ctx, AllContext&amp; all_ctx) \n{\n    auto other_ctx = all_ctx.template get&lt;OtherMiddleware&gt;();\n}\n</code></pre> </li> </ol>"},{"location":"guides/middleware/#local-middleware","title":"Local middleware","text":"<p>By default, every middleware is called for each request. If you want to enable middleware for specific handlers or blueprints, you have to extend it from <code>crow::ILocalMiddleware</code></p> <pre><code>struct LocalMiddleware : crow::ILocalMiddleware \n{\n</code></pre> <p>After this, you can enable it for specific handlers</p> <pre><code>CROW_ROUTE(app, \"/with_middleware\")\n.CROW_MIDDLEWARES(app, LocalMiddleware)\n([]() {\n    return \"Hello world!\";\n});\n</code></pre> <p>or blueprints</p> <pre><code>Blueprint bp(\"with_middleware\");\nbp.CROW_MIDDLEWARES(app, FistLocalMiddleware, SecondLocalMiddleware);\n</code></pre> <p>Warning</p> <p>Local and global middleware are called separately. First all global middleware is run, then all enabled local middleware for the current handler is run. In both cases middleware is called strongly in the order listed in the Crow application.</p>"},{"location":"guides/multipart/","title":"Multipart","text":"<p> v0.2</p> <p>Multipart is a way of forming HTTP requests or responses to contain multiple distinct parts.</p> <p>Such an approach allows a request to contain multiple different pieces of data with potentially conflicting data types in a single response payload. It is typically used either in HTML forms, or when uploading multiple files.</p>"},{"location":"guides/multipart/#how-multipart-messages-work","title":"How multipart messages work","text":"<p>The structure of a multipart request is typically consistent of:</p> <ul> <li>A Header: Typically <code>multipart/form-data;boundary=&lt;boundary&gt;</code>, This defines the HTTP message as being multipart, as well as defining the separator used to distinguish the different parts.</li> <li>1 or more parts:<ul> <li><code>--&lt;boundary&gt;</code></li> <li>Part header: typically <code>content-disposition: mime/type; name=\"&lt;fieldname&gt;\"</code> (<code>mime/type</code> should be replaced with the actual mime-type), can also contain a <code>filename</code> property (separated from the rest by a <code>;</code> and structured similarly to the <code>name</code> property)</li> <li>Value</li> </ul> </li> <li><code>--&lt;boundary&gt;--</code></li> </ul>"},{"location":"guides/multipart/#multipart-messages-in-crow","title":"Multipart messages in Crow","text":"<p>Crow supports multipart requests and responses though <code>crow::multipart::message</code>. A message can be created either by defining the headers, boundary, and individual parts and using them to create the message. or simply by reading a <code>crow::request</code>.</p> <p>Once a multipart message has been made, the individual parts can be accessed throughout <code>msg.parts</code>, <code>parts</code> is an <code>std::vector</code>.</p> <p> v1.0</p> <p>Part headers are organized in a similar way to request and response headers, and can be retrieved via <code>crow::multipart::get_header_object(\"header-key\")</code>. This function returns a <code>crow::multipart::header</code> object.</p> <p>The message's individual body parts can be accessed by name using <code>msg.get_part_by_name(\"part-name\")</code>.</p> <p>For more info on Multipart messages, go here</p>"},{"location":"guides/proxies/","title":"Proxies","text":"<p>You can set Crow up behind any HTTP proxy of your liking, but we will be focusing specifically on 2 of the most popular web server software solutions, Apache2 and Nginx.</p> <p>A reverse proxy allows you to use Crow without exposing it directly to the internet. It also allows you to, for example, have crow run on a certain specific domain name, subdomain, or even a path, such as <code>domain.abc/crow</code>.</p> <p>We advise that you set crow up behind some form of reverse proxy if you plan on running a production Crow server that isn't local.</p> <p>SSL</p> <p>When using a proxy, make sure that you do not compile Crow with SSL enabled. SSL should be handled by the proxy.</p>"},{"location":"guides/proxies/#apache2","title":"Apache2","text":"<p>Assuming you have both Apache2 and the modules proxy, proxy_http, proxy_html (if you plan on serving HTML pages), and proxy_wstunnel (if you plan on using websockets). You will need to enable those modules, which you can do using the following commands:</p> <pre><code>a2enmod proxy\na2enmod proxy_http\na2enmod proxy_html\na2enmod proxy_wstunnel\n</code></pre> <p>Next up you'll need to change your configuration (default is <code>/etc/apache2/sites-enabled/000-default.conf</code>) and add the following lines (replace <code>localhost</code> and <code>40080</code> with the address and port you defined for your Crow App): <pre><code>ProxyPass / http://localhost:40080\nProxyPassReverse / http://localhost:40080\n</code></pre> If you want crow to run in a subdirectory (such as <code>domain.abc/crow</code>) you can use the <code>location</code> tag: <pre><code>&lt;Location \"/crow\"&gt;\n\n    ProxyPass http://localhost:40080\n\n    ProxyPassReverse http://localhost:40080\n\n&lt;/Location&gt;\n</code></pre></p> <p>Note</p> <p>If you're using an Arch Linux based OS. You will have to access <code>/etc/httpd/conf/httpd.conf</code> to enable modules and change configuration.</p>"},{"location":"guides/proxies/#nginx","title":"Nginx","text":"<p>Setting Nginx up is slightly simpler than Apache, all you need is the Nginx package itself. Once you've installed it, go to the configuration file (usually a <code>.conf</code> file located in <code>/etc/nginx</code>) and add the following lines to your server section (replace <code>localhost</code> and <code>40080</code> with the address and port you defined for your Crow App):</p> <p><pre><code>location / {\n    proxy_pass http://localhost:40080/;\n    proxy_http_version 1.1;\n}\n</code></pre> Remember to remove or comment out any existing <code>location /</code> section.</p> <p>Alternatively, if you want to use a subdirectory, you can simply change the location parameter as such:</p> <pre><code>location /crow/ {\n    proxy_pass http://localhost:40080/;\n    proxy_http_version 1.1;\n}\n</code></pre>"},{"location":"guides/query-string/","title":"Query Strings","text":"<p>A query string is the part of the URL that comes after a <code>?</code> character, it is usually formatted as <code>key=value&amp;otherkey=othervalue</code>. </p> <p>Crow supports query strings through <code>crow::request::url_params</code>. The object is of type <code>crow::query_string</code> and can has the following functions:</p>"},{"location":"guides/query-string/#getname","title":"get(name)","text":"<p>Returns the value (as char*) based on the given key (or name). Returns <code>nullptr</code> if the key is not found.</p>"},{"location":"guides/query-string/#popname","title":"pop(name)","text":"<p> v0.3</p> <p>Works the same as <code>get</code>, but removes the returned value.</p> <p>Note</p> <p><code>crow::request::url_params</code> is a const value, therefore for pop (also pop_list and pop_dict) to work, a copy needs to be made.</p>"},{"location":"guides/query-string/#get_listname","title":"get_list(name)","text":"<p>A URL can be <code>http://example.com?key[]=value1&amp;key[]=value2&amp;key[]=value3</code>. Using <code>get_list(\"key\")</code> on such a URL returns an <code>std::vector&lt;std::string&gt;</code> containing <code>[value1, value2, value3]</code>.</p> <p><code>get_list(\"key\", false)</code> can be used to parse <code>http://example.com?key=value1&amp;key=value2&amp;key=value3</code></p>"},{"location":"guides/query-string/#pop_listname","title":"pop_list(name)","text":"<p> v0.3</p> <p>Works the same as <code>get_list</code> but removes all instances of values having the given key (<code>use_brackets</code> is also available here).</p>"},{"location":"guides/query-string/#get_dictname","title":"get_dict(name)","text":"<p>Returns an <code>std::unordered_map&lt;std::string, std::string&gt;</code> from a query string such as <code>?key[sub_key1]=value1&amp;key[sub_key2]=value2&amp;key[sub_key3]=value3</code>. The key in the map is what's in the brackets (<code>sub_key1</code> for example), and the value being what's after the <code>=</code> sign (<code>value1</code>). The name passed to the function is not part of the returned value.</p>"},{"location":"guides/query-string/#pop_dictname","title":"pop_dict(name)","text":"<p> v0.3</p> <p>Works the same as <code>get_dict</code> but removing the values from the query string.</p> <p>Warning</p> <p>if your query string contains both a list and dictionary with the same key, it is best to use <code>pop_list</code> before either <code>get_dict</code> or <code>pop_dict</code>, since a map cannot contain more than one value per key, each item in the list will override the previous and only the last will remain with an empty key.</p> <p> For more information take a look here.</p>"},{"location":"guides/routes/","title":"Routes","text":"<p>Routes define what happens when your client connects to a certain URL.</p>"},{"location":"guides/routes/#macro","title":"Macro","text":"<p><code>CROW_ROUTE(app, url)</code> Can be replaced with <code>app.route&lt;crow::black_magick::get_parameter_tag(url)&gt;(url)</code> or <code>app.route_dynamic(url)</code> if you're using VS2013 or want runtime URL evaluation. Although this usage is NOT recommended.</p>"},{"location":"guides/routes/#app","title":"App","text":"<p>Which app class to assign the route to.</p>"},{"location":"guides/routes/#path-url","title":"Path (URL)","text":"<p>Which relative path is assigned to the route. Using <code>/hello</code> means the client will need to access <code>http://example.com/hello</code> in order to access the route. A path can have parameters, for example <code>/hello/&lt;int&gt;</code> will allow a client to input an int into the url which will be in the handler (something like <code>http://example.com/hello/42</code>). Parameters can be <code>&lt;int&gt;</code>, <code>&lt;uint&gt;</code>, <code>&lt;double&gt;</code>, <code>&lt;string&gt;</code>, or <code>&lt;path&gt;</code>. It's worth noting that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: <pre><code>CROW_ROUTE(app, \"/add/&lt;int&gt;/&lt;int&gt;\")\n([](int a, int b)\n{\n    return std::to_string(a+b);\n});\n</code></pre> you can see the first <code>&lt;int&gt;</code> is defined as <code>a</code> and the second as <code>b</code>. If you were to run this and call <code>http://example.com/add/1/2</code>, the result would be a page with <code>3</code>. Exciting!</p>"},{"location":"guides/routes/#methods","title":"Methods","text":"<p>You can change the HTTP methods the route uses from just the default <code>GET</code> by using <code>method()</code>, your route macro should look like <code>CROW_ROUTE(app, \"/add/&lt;int&gt;/&lt;int&gt;\").methods(crow::HTTPMethod::GET, crow::HTTPMethod::PATCH)</code> or <code>CROW_ROUTE(app, \"/add/&lt;int&gt;/&lt;int&gt;\").methods(\"GET\"_method, \"PATCH\"_method)</code>.</p> <p>Note</p> <p>Crow handles <code>OPTIONS</code> method automatically. The <code>HEAD</code> method is handled automatically unless defined in a route. Adding <code>OPTIONS</code> to a route's methods has no effect.</p> <p>Crow defines the following methods: <pre><code>DELETE\nGET\nHEAD\nPOST\nPUT\n\nCONNECT\nOPTIONS\nTRACE\n\nPATCH\nPURGE\n\nCOPY\nLOCK\nMKCOL\nMOVE\nPROPFIND\nPROPPATCH\nSEARCH\nUNLOCK\nBIND\nREBIND\nUNBIND\nACL\n\nREPORT\nMKACTIVITY\nCHECKOUT\nMERGE\n\nSEARCH\nNOTIFY\nSUBSCRIBE\nUNSUBSCRIBE\n\nMKCALENDAR\n\nLINK\nUNLINK\n\nSOURCE\n</code></pre></p>"},{"location":"guides/routes/#handler","title":"Handler","text":"<p>Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression. It can be as simple as <code>([](){return \"Hello World\"})</code>.</p>"},{"location":"guides/routes/#request","title":"Request","text":"<p>Handlers can also use information from the request by adding it as a parameter <code>([](const crow::request&amp; req){...})</code>.</p> <p>You can also access the URL parameters in the handler using <code>req.url_params.get(\"param_name\");</code>. If the parameter doesn't exist, <code>nullptr</code> is returned.</p> <p>Note \u00a0\u00a0\u00a0\u00a0  master</p> <p>parameters inside the body can be parsed using <code>req.get_body_params();</code>. which is useful for requests of type <code>application/x-www-form-urlencoded</code>. Its format is similar to <code>url_params</code>.</p> <p>For more information on <code>crow::request</code> go here.</p>"},{"location":"guides/routes/#response","title":"Response","text":"<p>Crow also provides the ability to define a response in the parameters by using <code>([](crow::response&amp; res){...})</code>.</p> <p>Please note that in order to return a response defined as a parameter you'll need to use <code>res.end();</code>.</p> <p>Alternatively, you can define the response in the body and return it (<code>([](){return crow::response()})</code>).</p> <p>For more information on <code>crow::response</code> go here.</p> <p>Crow defines the following status codes: <pre><code>100 Continue\n101 Switching Protocols\n\n200 OK\n201 Created\n202 Accepted\n203 Non-Authoritative Information\n204 No Content\n205 Reset Content\n206 Partial Content\n\n300 Multiple Choices\n301 Moved Permanently\n302 Found\n303 See Other\n304 Not Modified\n307 Temporary Redirect\n308 Permanent Redirect\n\n400 Bad Request\n401 Unauthorized\n403 Forbidden\n404 Not Found\n405 Method Not Allowed\n407 Proxy Authentication Required\n409 Conflict\n410 Gone\n413 Payload Too Large\n415 Unsupported Media Type\n416 Range Not Satisfiable\n417 Expectation Failed\n428 Precondition Required\n429 Too Many Requests\n451 Unavailable For Legal Reasons\n\n500 Internal Server Error\n501 Not Implemented\n502 Bad Gateway\n503 Service Unavailable\n504 Gateway Timeout\n506 Variant Also Negotiates\n</code></pre></p> <p>Note</p> <p>If your status code is not defined in the list above (e.g. <code>crow::response(123)</code>) Crow will return <code>500 Internal Server Error</code> instead.</p>"},{"location":"guides/routes/#return-statement","title":"Return statement","text":"<p>A <code>crow::response</code> is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is <code>std::string</code>, although you could also return a <code>crow::json::wvalue</code> or <code>crow::multipart::message</code> directly. For more information on the specific constructors for a <code>crow::response</code> go here.</p>"},{"location":"guides/routes/#returning-custom-classes","title":"Returning custom classes","text":"<p> v0.3</p> <p>If you have your own class you want to return (without converting it to string and returning that), you can use the <code>crow::returnable</code> class. to use the returnable class, you only need your class to publicly extend <code>crow::returnable</code>, add a <code>dump()</code> method that returns your class as an <code>std::string</code>, and add a constructor that has a <code>Content-Type</code> header as a string argument.</p> <p>Your class should look like the following: <pre><code>class a : public crow::returnable\n{\n    a() : returnable(\"text/plain\"){};\n\n    ...\n    ...\n    ...\n\n    std::string dump() const override\n    {\n        return this.as_string();\n    }\n}\n</code></pre> </p>"},{"location":"guides/routes/#response-codes","title":"Response codes","text":"<p> v1.0</p> <p>Instead of assigning a response code, you can use the <code>crow::status</code> enum, for example you can replace <code>crow::response(200)</code> with <code>crow::response(crow::status::OK)</code></p>"},{"location":"guides/routes/#catchall-routes","title":"Catchall routes","text":"<p> v0.3</p> <p>By default, any request that Crow can't find a route for will return a simple 404 response. You can change that to return a default route using the <code>CROW_CATCHALL_ROUTE(app)</code> macro. Defining it is identical to a normal route, even when it comes to the <code>const crow::request&amp;</code> and <code>crow::response&amp;</code> parameters being optional.</p> <p>Note</p> <p>For versions higher than 0.3 (excluding patches), Catchall routes handle 404 and 405 responses. The default response will contain the code 404 or 405.</p>"},{"location":"guides/ssl/","title":"SSL","text":"<p>Crow supports HTTPS though SSL or TLS.</p> <p>Note</p> <p>When mentioning SSL in this documentation, it is often a reference to openSSL, which includes TLS.</p> <p>To enable SSL, first your application needs to define either a <code>.crt</code> and <code>.key</code> files, or a <code>.pem</code> file. Once you have your files, you can add them to your app like this: <code>app.ssl_file(\"/path/to/cert.crt\", \"/path/to/keyfile.key\")</code> or <code>app.ssl_file(\"/path/to/pem_file.pem\")</code>. Please note that this method can be part of the app method chain, which means it can be followed by <code>.run()</code> or any other method.</p> <p>You also need to define <code>CROW_ENABLE_SSL</code> in your compiler definitions (<code>g++ main.cpp -DCROW_ENABLE_SSL</code> for example) or <code>set(CROW_FEATURES ssl)</code> in <code>CMakeLists.txt</code>.</p> <p>You can also set your own SSL context (by using <code>asio::ssl::context ctx</code>) and then applying it via the <code>app.ssl(ctx)</code> method.</p> <p>Warning</p> <p>If you plan on using a proxy like Nginx or Apache2, DO NOT use SSL in crow, instead define it in your proxy and keep the connection between the proxy and Crow non-SSL.</p>"},{"location":"guides/static/","title":"Static Files","text":"<p> v0.2</p> <p>A static file is any file that resides in the server's storage.</p> <p>Crow supports returning static files as responses either implicitly or explicitly.</p>"},{"location":"guides/static/#implicit","title":"Implicit","text":"<p>Crow implicitly returns any static files placed in a <code>static</code> directory and any subdirectories, as long as the user calls the endpoint <code>/static/path/to/file</code>. The static folder or endpoint can be changed by defining the macros <code>CROW_STATIC_DIRECTORY \"alternative_directory/\"</code> and <code>CROW_STATIC_ENDPOINT \"/alternative_endpoint/&lt;path&gt;\"</code>. static directory changes the directory in the server's file system, while the endpoint changes the URL that the client needs to access.</p>"},{"location":"guides/static/#explicit","title":"Explicit","text":"<p>You can directly return a static file by using the <code>crow::response</code> method <code>response.set_static_file_info(\"path/to/file\");</code>. The path is relative to the working directory.</p> <p>Warning</p> <p>The path to the file is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use <code>response.set_static_file_info_unsafe(\"path/to/file\")</code> instead.</p> <p>Note</p> <p>Crow sets the <code>content-type</code> header automatically based on the file's extension, if an extension is unavailable or undefined,  Crow uses <code>text/plain</code>, if you'd like to explicitly set a <code>content-type</code>, use <code>response.set_header(\"content-type\", \"mime/type\");</code> AFTER calling <code>set_static_file_info</code>.</p> <p>Note</p> <p>Please keep in mind that using the <code>set_static_file_info</code> method means any data already in your response body is ignored and not sent to the client.</p>"},{"location":"guides/syste/","title":"Systemd run on startup","text":"<p>Using Systemd allows you to run any executable or script when the system starts. This can be useful when you don't want to re-run your Crow application every single time you restart your server.</p>"},{"location":"guides/syste/#writing-the-service-unit-file","title":"Writing the Service Unit File","text":"<p>In order to have Systemd recognize your application, you need to create a <code>.service</code> file that explains how Systemd should handle your program.</p> <p>To create a service file, you need to go to <code>/etc/systemd/system</code> and create an empty text file with the extension <code>.service</code>, the file name can be anything.</p> <p>Once the file is created, open it using your favorite text editor and add the following:</p> <pre><code>[Unit]\nDescription=My revolutionary Crow application\n\nWants=network.target\nAfter=syslog.target network-online.target\n\n[Service]\nType=simple\nExecStart=/absolute/path/to/your/executable\nRestart=on-failure\nRestartSec=10\nKillMode=process\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>You will then need to give the correct permission, this can be done by using the following command (a <code>sudo</code> maybe required):</p> <pre><code>chmod 640 /etc/systemd/system/crowthing.service\n</code></pre> <p>And that's it! You can now use your <code>systemctl</code> controls to <code>enable</code>, <code>start</code>, <code>stop</code>, or <code>disable</code> your Crow application.</p> <p>If you're not familiar with Systemd, <code>systemctl enable crowthing.service</code> will allow your Crow application to run at startup, <code>start</code> will start it, and the rest is simple.</p>"},{"location":"guides/templating/","title":"Templating (Mustache)","text":"<p>Templating is when you return an HTML page with custom data. You can probably tell why that's useful.</p> <p>Crow supports mustache for templates through its own implementation <code>crow::mustache</code>.</p> <p>Note</p> <p>Currently Crow's Mustache implementation is not linked to the Crow application, meaning if an executable has more than one Crow application they'll be sharing any variables or classes relating to template loading and compiling.</p>"},{"location":"guides/templating/#components-of-mustache","title":"Components of mustache","text":"<p>There are 2 components of a mustache template implementation:</p> <ul> <li>Page</li> <li>Context</li> </ul>"},{"location":"guides/templating/#page","title":"Page","text":"<p>The HTML page (including the mustache tags). It is usually loaded into <code>crow::mustache::template_t</code>. It needs to be placed in the templates directory which should be directly inside the current working directory of the crow executable.</p> <p>The templates directory is usually called <code>templates</code>, but can be adjusted per Route (via <code>crow::mustache::set_base(\"new_templates_directory\")</code>), per Blueprint, or globally (via <code>crow::mustache::set_global_base(\"new_templates_directory\"\")</code>).</p> <p>For more information on how to formulate a template, see this mustache manual.</p>"},{"location":"guides/templating/#context","title":"Context","text":"<p>A JSON object containing the tags as keys and their values. <code>crow::mustache::context</code> is actually a crow::json::wvalue.</p> <p>Note</p> <p><code>crow::mustache::context</code> can take a C++ lambda as a value. The lambda needs to take a string as an argument and return a string, such as <code>ctx[lmd] = [&amp;](std::string){return \"Hello World\";};</code>.</p> <p>Note</p> <p>The string returned by the lamdba can contain mustache tags, Crow will parse it as any normal template string.</p>"},{"location":"guides/templating/#returning-a-template","title":"Returning a template","text":"<p>To return a mustache template, you need to load a page using <code>auto page = crow::mustache::load(\"path/to/template.html\");</code>. Or just simply load a string using <code>auto page = crow::mustache::compile(\"my mustache {{value}}\");</code>. Keep in mind that the path is relative to the templates directory.</p> <p>Note</p> <p>You can also use <code>auto page = crow::mustache::load_text(\"path/to/template.html\");</code> if you want to load a template without mustache processing.</p> <p>Warning</p> <p>The path to the template is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use <code>crow::mustache::load_unsafe()</code> instead.</p> <p> You also need to set up the context by using <code>crow::mustache::context ctx;</code>. Then you need to assign the keys and values, this can be done the same way you assign values to a JSON write value (<code>ctx[\"key\"] = value;</code>). With your context and page ready, just <code>return page.render(ctx);</code>. This will use the context data to return a filled template. Alternatively you could just render the page without a context using <code>return page.render();</code>.</p> <p>Note</p> <p><code>page.render();</code> returns a crow::returnable class in order to set the <code>Content-Type</code> header. to get a simple string, use <code>page.render_string()</code> instead.</p>"},{"location":"guides/testing/","title":"Writing Tests","text":"<p>Unit tests can be written in 2 ways for a Crow application.</p>"},{"location":"guides/testing/#the-handler-method","title":"The handler method","text":"<p>Crow allows users to handle requests that may not come from the network. This is done by calling the <code>handle(req, res)</code> method and providing a request and response objects. Which causes crow to identify and run the appropriate handler, returning the resulting response.</p> <pre><code>  CROW_ROUTE(app, \"/place\")\n  ([] { return \"hi\"; });\n\n  app.validate();  //Used to make sure all the route handlers are in order.\n\n  {\n    request req;\n    response res;\n\n    req.url = \"/place\";\n\n    app.handle(req, res); //res will contain a code of 200, and a response body of \"hi\"\n  }\n</code></pre> <p>Note</p> <p>This method is the simpler of the two and is usually all you really need to test your routes.</p> <p>Warning</p> <p>This method does not send any data, nor does it run any post handle code, so things like static file serving (as far as sending the actual data) or compression cannot be tested using this method.</p>"},{"location":"guides/testing/#the-client-method","title":"The client method","text":"<p>This method involves creating a simple ASIO client that sends the request and receives the response. It is considerably more complex than the earlier method, but it is both more realistic and includes post handle operations.</p> <p><pre><code>  static char buf[2048];\n  SimpleApp app;\n  CROW_ROUTE(app, \"/\")([] { return \"A\"; });\n\n  auto _ = async(launch::async,[&amp;] { app1.bindaddr(\"127.0.0.1\").port(45451).run(); });\n  app.wait_for_server_start();\n\n  std::string sendmsg = \"GET /\\r\\nContent-Length:3\\r\\nX-HeaderTest: 123\\r\\n\\r\\nA=B\\r\\n\";\n  asio::io_service is;\n  {\n    asio::ip::tcp::socket c(is);\n    c.connect(asio::ip::tcp::endpoint(asio::ip::address::from_string(\"127.0.0.1\"), 45451));\n\n    c.send(asio::buffer(sendmsg));\n\n    size_t recved = c.receive(asio::buffer(buf, 2048));\n    CHECK('A' == buf[recved - 1]); //This is specific to catch2 testing library, but it should give a general idea of how to read the response.\n  }\n\n  app.stop(); //THIS MUST RUN\n}\n</code></pre> The first part is straightforward, create an app and add a route. The second part is launching the app asynchronously and waiting until it starts. The third is formulating our HTTP request string, the format is: <pre><code>METHOD /\nContent-Length:123\nheader1:value1\nheader2:value2\n\nBODY\n</code></pre> Next an <code>io_service</code> is created, then a TCP socket is created with the <code>io_service</code> and is connected to the application. Then send the HTTP request string through the socket inside a buffer, and read the result into the buffer in <code>line 1</code>. Finally check the result against the expected one.</p> <p>Warning</p> <p>Be absolutely sure that the line <code>app.stop()</code> runs, whether the test fails or succeeds. Not running it WILL CAUSE OTHER TESTS TO FAIL AND THE TEST TO HANG UNTIL THE PROCESS IS TERMINATED.</p>"},{"location":"guides/websockets/","title":"Websockets","text":"<p>Websockets are a way of connecting a client and a server without the request response nature of HTTP.</p>"},{"location":"guides/websockets/#routes","title":"Routes","text":"<p>To create a websocket in Crow, you need a websocket route. A websocket route differs from a normal route quite a bit. It uses a slightly altered <code>CROW_WEBSOCKET_ROUTE(app, \"/url\")</code> macro, which is then followed by a series of methods (with handlers inside) for each event. These are (sorted by order of execution):</p> <ul> <li><code>onaccept([&amp;](const crow::request&amp; req, void** userdata){handler code goes here})</code></li> <li><code>onopen([&amp;](crow::websocket::connection&amp; conn){handler code goes here})</code></li> <li><code>onmessage([&amp;](crow::websocket::connection&amp; conn, const std::string&amp; message, bool is_binary){handler code goes here})</code></li> <li><code>onerror([&amp;](crow::websocket::connection&amp; conn, const std::string&amp; error_message){handler code goes here})</code></li> <li><code>onclose([&amp;](crow::websocket::connection&amp; conn, const std::string&amp; reason){handler code goes here})</code></li> </ul> <p>Note</p> <p><code>onaccept</code> must return a boolean. In case <code>false</code> is returned, the connection is shut down, deleted, and no further communication is done.</p> <p>Warning</p> <p>By default, Crow allows clients to send unmasked websocket messages. This is useful for debugging, but goes against the protocol specifications. Production Crow applications should enforce the protocol by adding <code>#define CROW_ENFORCE_WS_SPEC</code> to their source code.</p> <p>These event methods and their handlers can be chained. The full route should look similar to this: <pre><code>CROW_WEBSOCKET_ROUTE(app, \"/ws\")\n    .onopen([&amp;](crow::websocket::connection&amp; conn){\n            do_something();\n            })\n    .onclose([&amp;](crow::websocket::connection&amp; conn, const std::string&amp; reason){\n            do_something();\n            })\n    .onmessage([&amp;](crow::websocket::connection&amp; /*conn*/, const std::string&amp; data, bool is_binary){\n                if (is_binary)\n                    do_something(data);\n                else\n                    do_something_else(data);\n            });\n</code></pre></p>"},{"location":"guides/websockets/#maximum-payload-size","title":"Maximum payload size","text":"<p> master</p> <p>The maximum payload size that a connection accepts can be adjusted either globally by using <code>app.websocket_max_payload(&lt;value in bytes&gt;)</code> or per route by using <code>CROW_WEBSOCKET_ROUTE(app, \"/url\").max_payload(&lt;value in bytes&gt;)</code>. In case a message was sent that exceeded the limit. The connection would be shut down and <code>onerror</code> would be triggered.</p> <p>Note</p> <p>By default, this limit is disabled. To disable the global setting in specific routes, you only need to call <code>CROW_WEBSOCKET_ROUTE(app, \"/url\").max_payload(UINT64_MAX)</code>.</p> <p>For more info about websocket routes go here.</p> <p>For more info about websocket connections go here.</p>"}]}